// machine.cc 
//	Routines for simulating the execution of user programs.
//
//  DO NOT CHANGE -- part of the machine emulation
//
// Copyright (c) 1992-1996 The Regents of the University of California.
// All rights reserved.  See copyright.h for copyright notice and limitation 
// of liability and disclaimer of warranty provisions.

#include "copyright.h"
#include "machine.h"
#include "main.h"
#include "noff.h"//Jess

// Textual names of the exceptions that can be generated by user program
// execution, for debugging.
static char* exceptionNames[] = { "no exception", "syscall", 
				"page fault/no TLB entry", "page read only",
				"bus error", "address error", "overflow",
				"illegal instruction" };

//----------------------------------------------------------------------
// CheckEndian
// 	Check to be sure that the host really uses the format it says it 
//	does, for storing the bytes of an integer.  Stop on error.
//----------------------------------------------------------------------

static
void CheckEndian()
{
    union checkit {
        char charword[4];
        unsigned int intword;
    } check;

    check.charword[0] = 1;
    check.charword[1] = 2;
    check.charword[2] = 3;
    check.charword[3] = 4;

#ifdef HOST_IS_BIG_ENDIAN
    ASSERT (check.intword == 0x01020304);
#else
    ASSERT (check.intword == 0x04030201);
#endif
}

//----------------------------------------------------------------------
// Machine::Machine
// 	Initialize the simulation of user program execution.
//
//	"debug" -- if TRUE, drop into the debugger after each user instruction
//		is executed.
//----------------------------------------------------------------------

Machine::Machine(bool debug)
{
    int i;

    for (i = 0; i < NumTotalRegs; i++)
        registers[i] = 0;
    mainMemory = new char[MemorySize];
    for (i = 0; i < MemorySize; i++)
      	mainMemory[i] = 0;

    mBitmap = new BitMap(NumPhysPages); //Jess
#ifdef USE_TLB
    tlb = new TranslationEntry[TLBSize];
    for (i = 0; i < TLBSize; i++)
	tlb[i].valid = FALSE;
    pageTable = NULL;
#else	// use linear page table
    tlb = NULL;
    pageTable = NULL;
#endif

    singleStep = debug;
    CheckEndian();
}

//----------------------------------------------------------------------
// Machine::~Machine
// 	De-allocate the data structures used to simulate user program execution.
//----------------------------------------------------------------------

Machine::~Machine()
{
    delete [] mainMemory;
    if (tlb != NULL)
        delete [] tlb;
}

//----------------------------------------------------------------------
// Machine::RaiseException
// 	Transfer control to the Nachos kernel from user mode, because
//	the user program either invoked a system call, or some exception
//	occured (such as the address translation failed).
//
//	"which" -- the cause of the kernel trap
//	"badVaddr" -- the virtual address causing the trap, if appropriate
//----------------------------------------------------------------------

void
Machine::RaiseException(ExceptionType which, int badVAddr)
{
    DEBUG(dbgMach, "Exception: " << exceptionNames[which]);
    
    registers[BadVAddrReg] = badVAddr;
    DelayedLoad(0, 0);			// finish anything in progress
    kernel->interrupt->setStatus(SystemMode);
//	cout << "entering system mode...\n";
    ExceptionHandler(which);		// interrupts are enabled at this point
    kernel->interrupt->setStatus(UserMode);
//	cout << "entering user mode...\n";
}

//----------------------------------------------------------------------
// Machine::Debugger
// 	Primitive debugger for user programs.  Note that we can't use
//	gdb to debug user programs, since gdb doesn't run on top of Nachos.
//	It could, but you'd have to implement *a lot* more system calls
//	to get it to work!
//
//	So just allow single-stepping, and printing the contents of memory.
//----------------------------------------------------------------------

void Machine::Debugger()
{
    char *buf = new char[80];
    int num;

    kernel->interrupt->DumpState();
    DumpState();
    cout << kernel->stats->totalTicks << ">";
    cin.get(buf, 80, '\n');
    if (sscanf(buf, "%d", &num) == 1)
	runUntilTime = num;
    else {
	runUntilTime = 0;
	switch (*buf) {
	  case '\n':
	    break;
	    
	  case 'c':
	    singleStep = FALSE;
	    break;
	    
	  case '?':
	    cout << "Machine commands:\n";
	    cout << "    <return>  execute one instruction\n";
	    cout << "    <number>  run until the given timer tick\n";
	    cout << "    c         run until completion\n";
	    cout << "    ?         print help message\n";
	    break;
	}
    }
    delete [] buf;
}
 
//----------------------------------------------------------------------
// Machine::DumpState
// 	Print the user program's CPU state.  We might print the contents
//	of memory, but that seemed like overkill.
//----------------------------------------------------------------------

void
Machine::DumpState()
{
    int i;
    
    cout << "Machine registers:\n";
    for (i = 0; i < NumGPRegs; i++) {
	switch (i) {
	  case StackReg:
	    cout << "\tSP(" << i << "):\t" << registers[i];
	    break;
	    
	  case RetAddrReg:
	    cout << "\tRA(" << i << "):\t" << registers[i];
	    break;
	  
	  default:
	    cout << "\t" << i << ":\t" << registers[i];
	    break;
	}
	if ((i % 4) == 3) { cout << "\n"; }
    }
    
    cout << "\tHi:\t" << registers[HiReg];
    cout << "\tLo:\t" << registers[LoReg];
    cout << "\tPC:\t" << registers[PCReg];
    cout << "\tNextPC:\t" << registers[NextPCReg];
    cout << "\tPrevPC:\t" << registers[PrevPCReg];
    cout << "\tLoad:\t" << registers[LoadReg];
    cout << "\tLoadV:\t" << registers[LoadValueReg] << "\n";
}

//----------------------------------------------------------------------
// Machine::ReadRegister/WriteRegister
//   	Fetch or write the contents of a user program register.
//----------------------------------------------------------------------

int 
Machine::ReadRegister(int num)
{
    ASSERT((num >= 0) && (num < NumTotalRegs));
    return registers[num];
}

void 
Machine::WriteRegister(int num, int value)
{
    ASSERT((num >= 0) && (num < NumTotalRegs));
    registers[num] = value;
}



bool 
Machine::swapPage(int addr)
{
	
	unsigned int vpn = addr/PageSize;
	unsigned int offset = addr%PageSize;
	int swapVpn = -1; //victim
	unsigned int ppn = kernel->machine->mBitmap->Find();
	int min = pageTable[0].lastUseTime; //last use ticks


	if(ppn==-1) //LRU find victim
	{
		ppn = 0;
		for(unsigned int i = 0;i < pageTableSize; i++)
		{
			if(pageTable[i].lastUseTime < min && pageTable[i].valid == TRUE)
			{
				min = pageTable[i].lastUseTime;
				ppn = pageTable[i].physicalPage;
				swapVpn = i; //victim
			}
		}	
	}
	//DEBUG('p',"ppn:%d\n",ppn);
	if(ppn == -1)
		return FALSE;

	//從硬碟中載入該頁的資料
	NoffHeader noffH = kernel->machine->noffH;
	
	//int vAddr = vpn*PageSize; //該頁的虛擬起始地址	 
	//DEBUG('p',"addr:%d,pAddr:%d,vAddr:%d\n",addr,pAddr,vAddr);  
	//DEBUG('p',"code.virtualAddr:%d,code.size:%d,code.inFileAddr:%d\n",
	//	noffH.code.virtualAddr,noffH.code.size,noffH.code.inFileAddr); 
	//DEBUG('p',"initData.virtualAddr:%d,initData.size:%d,initData.inFileAddr:%d\n",
	//	noffH.initData.virtualAddr,noffH.initData.size,noffH.initData.inFileAddr); 
	//DEBUG('p',"openFile:%d\n",executable->GetFileId());  	
	//判斷置換頁中的每一個位元組是在程式碼段還是在資料段	
	for(int i = 0;i < PageSize;i++)
	{
		int vAddr = vpn*PageSize + i;	//要拷貝的位元組的虛擬地址
		int pAddr = ppn*PageSize + i; 	//要拷貝的位元組的實體地址
	   //如果在程式碼段
	   if(vAddr>=noffH.code.virtualAddr
		&&vAddr<(noffH.code.virtualAddr+noffH.code.size))
	   {
		kernel->machine->executable->ReadAt(&(kernel->machine->mainMemory[pAddr]),
			1,noffH.code.inFileAddr+vAddr);
	   }//如果在資料段
	   else if(addr>=noffH.initData.virtualAddr
		&&addr<(noffH.initData.virtualAddr+noffH.initData.size))
	   {
		kernel->machine->executable->ReadAt(&(kernel->machine->mainMemory[pAddr]),
			1,noffH.initData.inFileAddr+vAddr-noffH.initData.virtualAddr);
	   }
	}

	//更新pagevTable表		
	pageTable[vpn].virtualPage = vpn;
	pageTable[vpn].physicalPage = ppn;
	pageTable[vpn].valid = TRUE;
	pageTable[vpn].lastUseTime = stats->totalTicks;
	//更新被置換掉的頁表項
	if(swapVpn != -1)
	{
	    pageTable[swapVpn].physicalPage = 0;
	    pageTable[swapVpn].valid = FALSE;
	    //如果被置換掉的頁已經被修改
	    //寫回到磁碟
	    if(pageTable[swapVpn].dirty == TRUE)
	   {
		DEBUG('p',"swap the page to disk.\n");	
	   }
	}

	return TRUE;
}


void
Machine::LRUSwap(int addr){
	DEBUG('p',"TLB MISS,use LRU swap\n");
    unsigned int vpn = addr / PageSize;					//虚拟页号
    unsigned int min = tlb[0].lastUseTime;				//最小时间
    TranslationEntry *entry = &tlb[0];				//置换的页表项
    
    for(int i = 0; i< TLBSize;i++){
	if(tlb[i].valid == FALSE)			//如果有空项，直接返回
	{
	    entry = &tlb[i];
	    break;
	}					    
	if(tlb[i].lastUseTime < min)			//找到时间最小的一项，即为需要置换的项
	{
	   min = tlb[i].lastUseTime;
	   entry = &tlb[i];		
	 }
    }
    
    //置换该项
    if(entry->valid != FALSE)
	    pageTable[entry->virtualPage] = *entry;						
    *entry = pageTable[vpn];
    entry->lastUseTime = stats->totalTicks;
 
    //打印tlb中的内容
 

}
